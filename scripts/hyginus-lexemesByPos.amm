val myBT = coursierapi.MavenRepository.of("https://dl.bintray.com/neelsmith/maven")
interp.repositories() ++= Seq(myBT)

import $ivy.`edu.holycross.shot::ohco2:10.18.2`
import $ivy.`edu.holycross.shot.cite::xcite:4.2.0`
import $ivy.`edu.holycross.shot::midvalidator:10.0.0`
import $ivy.`edu.holycross.shot::latincorpus:2.2.2`
import $ivy.`edu.holycross.shot::latphone:2.7.2`
// It would be nice to visualize, so let's use the
// plotly library with ammonite sh:
// Make plotly libraries available to this notebook:
import $ivy.`org.plotly-scala::plotly-almond:0.7.1`

// Import plotly libraries, and set display defaults suggested for use in Jupyter NBs:
import plotly._, plotly.element._, plotly.layout._, plotly.Almond._
repl.pprinter() = repl.pprinter().copy(defaultHeight = 3)


import edu.holycross.shot.cite._
import edu.holycross.shot.ohco2._
import edu.holycross.shot.latin._
import edu.holycross.shot.mid.validator._
import edu.holycross.shot.latincorpus._

import scala.io.Source


// 1. Load a citable corpus from a URL
val hyginusUrl = "https://raw.githubusercontent.com/neelsmith/hctexts/master/cex/hyginus.cex"
val corpus = CorpusSource.fromUrl(hyginusUrl, cexHeader = true)

// 2. Add orthography to create a tokenizable corpus.
// Be patient: it can take a moment to tokenize your complete corpus.
val tcorpus = TokenizableCorpus(corpus, Latin23Alphabet )


// 3. Add morphological parsing to create a `LatinCorpus`
val hyginusFstUrl = "https://raw.githubusercontent.com/neelsmith/hctexts/master/parser-output/hyginus/hyginus-parses.txt"
val fstOutput = Source.fromURL(hyginusFstUrl).getLines.toVector

// This step can take a moment, too, as it attempts to associate a
// morphological analysis with every lexical token.
val lhyg = LatinCorpus.fromFstLines(
  corpus,
  Latin23Alphabet,
  fstOutput,
  strict = false
)
val hygHist = lhyg.lexemeHistogram
//////////////////////////END BASIC SETUP ////////////////////////////////////



val posIdCounts = lhyg.analyzed.map(a =>
  {
    val id = a.analyses(0).lemmaId
    val pos = a.analyses(0).posLabel
   (id, pos,hygHist.countForItem(id))
 }).distinct


val posMap = posIdCounts.groupBy{ case (id,pos,count) => pos }
val posOccurrences = posMap.toVector.map{ case (pos,v) => (pos, v.map(_._3).sum)}
val posLexemeCounts = posMap.toVector.map{ case (pos,v) => (pos, v.size) }



val lexemeCounts = posLexemeCounts.sortBy( _._1).map(_._2)
val occurrenceCounts = posOccurrences.sortBy(_._1).map(_._2)
val posList = posLexemeCounts.sortBy( _._1).map(_._1)


val occurrences =  Bar(x = posList, y = occurrenceCounts, name = "Occurrences")
val lexemes =  Bar(x = posList, y = lexemeCounts, name = "Number of lexemes")


val jointLayout = Layout(
  barmode = BarMode.Group,
    xaxis = Axis(
        title = "Analytical type",
        showgrid = false,
        zeroline = false
    ),
    yaxis = Axis(
        title = "Counts"
    )
)
val jointData = Seq(
  occurrences,
  lexemes
)
plot(jointData, jointLayout)

val density = lexemeCounts.zip(occurrenceCounts).map {
  case (lex,occ) => lex.toDouble / occ
}


val densityPlot = Vector(
  Bar(x = posList, y = density)
)
val densityLayout = Layout(
  title = "Lexemes per part of speech",
  xaxis = Axis(
      title = "Analytical type",
      showgrid = false,
      zeroline = false
  ),
  yaxis = Axis(
      title = "Ratio of lexemes to occurrences"
  )
)
plot(densityPlot, densityLayout)
